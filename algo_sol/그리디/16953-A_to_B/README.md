# 📝 Baekjoon 16953: A_to_B

| **Solved Date** | **Difficulty** | **Algorithm** | **Link** |
|:---:|:---:|:---:|:---:|
| 2025-09-08 | ![실버 2](https://img.shields.io/badge/Silver-2-949393?style=for-the-badge) | `그리디` | [16953번 문제](https://www.acmicpc.net/problem/16953) |

<br/>

## ✨ AI Code Analysis

> AI가 요약한 핵심 아이디어 및 전략입니다.

### 🧠 **핵심 아이디어**

문제는 주어진 숫자 `m`을 1로 만들기 위한 연산 횟수를 구하는 것입니다.  `m`을 1로 만들기 위해서는 다음 두 가지 연산만 허용됩니다: 1) 짝수일 경우 2로 나누기, 2) 1로 끝나는 수일 경우 10으로 나누기(마지막 자리의 1 제거).  `m`이 `n`이 되거나, 연산 과정에서 `n`보다 작아지는 경우는 불가능한 경우로 처리합니다.


### 📝 **알고리즘**

`m`이 1이 될 때까지 반복문을 수행합니다. 각 반복마다 다음과 같은 조건을 검사합니다.

1. **`m % 10 == 1`:** `m`이 1로 끝나면 10으로 나누고 카운트를 증가시킵니다.
2. **`m % 2 == 0`:** `m`이 짝수이면 2로 나누고 카운트를 증가시킵니다.
3. **그 외:** 위 두 조건에 해당하지 않으면 (즉, 홀수이고 1로 끝나지 않으면) 불가능한 경우이므로 카운트를 -1로 설정하고 반복문을 종료합니다.

매 반복마다 `m`이 `n`과 같은지 또는 `n`보다 작아졌는지 확인하고, 만약 그렇다면 불가능한 경우이므로 카운트를 -1로 설정하고 반복문을 종료합니다.  마지막으로 카운트를 출력합니다.


### 🧐 **시간 복잡도**

최악의 경우, `m`이 1이 될 때까지 반복문이 수행됩니다. `m`의 크기에 따라 반복 횟수가 결정되므로, 시간 복잡도는 O(log m) 입니다.  `m`을 2 또는 10으로 나누는 연산이 지배적이기 때문입니다.  만약 `m`이 10의 거듭제곱으로 구성된 숫자라면  로그 시간 복잡도를 갖습니다.  하지만  `m`의 구성에 따라 실제 연산 횟수는 달라질 수 있습니다.  하지만 입력값의 크기에 따라 선형적으로 증가하지 않고, 대략적으로 로그적 비율로 증가하기 때문에 O(log m)으로 표현하는 것이 적절합니다.


<br/>

<details>
<summary>💻 My Code (Click to expand)</summary>

````py
# Baekjoon Problem 16953: A_to_B
# https://www.acmicpc.net/problem/16953

n,m = map(int,input().split())

cnt = 1

while m != 1:
    if m % 10 == 1:
        m = m//10
        cnt += 1
    elif m % 2 == 0:
        m = m//2
        cnt += 1
    else:
        cnt = -1
        break

    if m == n:
        break
    elif m < n:
        cnt = -1
        break


print(cnt)
</details>